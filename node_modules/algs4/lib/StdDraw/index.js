"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var assert_1 = tslib_1.__importDefault(require("../utils/assert"));
var StdDraw = /** @class */ (function () {
    function StdDraw() {
    }
    StdDraw.line = function (x0, y0, x1, y1) {
        var ctx = StdDraw.ctx;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    };
    /**
     * Draws a point centered at (x, y).
     * The point is a filled circle whose radius is equal to the pen radius.
     * To draw a single-pixel point, first set the pen radius to 0.
     *
     * @param x the x-coordinate of the point
     * @param y the y-coordinate of the point
     * @throws Error if either x or y is either NaN or infinite
     */
    StdDraw.point = function (x, y) {
        StdDraw._assertXYSafeInt(x, y);
        var ctx = StdDraw.ctx;
        ctx.fillRect(x, y, 1, 1);
        // const id = ctx.createImageData(1, 1);
        // const d = id.data;
        // d[0] = 100;
        // d[1] = 100;
        // d[2] = 100;
        // d[3] = 0.5;
        // ctx.putImageData(id, x, y);
    };
    /**
     * Writes the given text string in the current font, centered at (x, y).
     *
     * @param  x the center x-coordinate of the text
     * @param  y the center y-coordinate of the text
     * @param  text the text to write
     * @throws Error if text is null
     * @throws Error if x or y is either NaN or infinite
     */
    StdDraw.text = function (x, y, text) {
        assert_1.default(!text, 'text is not valid');
        StdDraw._assertXYSafeInt(x, y);
        var ctx = StdDraw.ctx;
        ctx.fillText(text, x, y);
    };
    /**
     * Draws a circle of the specified radius, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the circle
     * @param  y the y-coordinate of the center of the circle
     * @param  radius the radius of the circle
     * @throws Error if radius is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.circle = function (x, y, radius) {
        var ctx = StdDraw.ctx;
        StdDraw._circlePath(x, y, radius);
        ctx.stroke();
    };
    /**
     * Draws a filled circle of the specified radius, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the circle
     * @param  y the y-coordinate of the center of the circle
     * @param  radius the radius of the circle
     * @throws Error if radius is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.filledCircle = function (x, y, radius) {
        var ctx = StdDraw.ctx;
        StdDraw._circlePath(x, y, radius);
        ctx.fill();
    };
    /**
     * Draws an ellipse with the specified semimajor and semiminor axes,
     * centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the ellipse
     * @param  y the y-coordinate of the center of the ellipse
     * @param  semiMajorAxis is the semimajor axis of the ellipse
     * @param  semiMinorAxis is the semiminor axis of the ellipse
     * @throws Error if either semiMajorAxis
     *         or semiMinorAxis is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.ellipse = function (x, y, semiMajorAxis, semiMinorAxis) {
        var ctx = StdDraw.ctx;
        StdDraw._ellipsePath(x, y, semiMajorAxis, semiMinorAxis);
        ctx.stroke();
    };
    /**
     * Draws a filled ellipse with the specified semimajor and semiminor axes,
     * centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the ellipse
     * @param  y the y-coordinate of the center of the ellipse
     * @param  semiMajorAxis is the semimajor axis of the ellipse
     * @param  semiMinorAxis is the semiminor axis of the ellipse
     * @throws Error if either semiMajorAxis
     *         or semiMinorAxis is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.filledEllipse = function (x, y, semiMajorAxis, semiMinorAxis) {
        var ctx = StdDraw.ctx;
        StdDraw._ellipsePath(x, y, semiMajorAxis, semiMinorAxis);
        ctx.fill();
    };
    /**
     * Draws a square of the specified size, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the square
     * @param  y the y-coordinate of the center of the square
     * @param  halfLength one half the length of any side of the square
     * @throws Error if halfLength is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.square = function (x, y, halfLength) {
        assert_1.default(halfLength <= 0, 'halfLength must be positive number');
        StdDraw._assertXYSafeInt(x, y);
        var x0 = x - halfLength;
        var y0 = y - halfLength;
        var sideLength = 2 * halfLength;
        var ctx = StdDraw.ctx;
        ctx.strokeRect(x0, y0, sideLength, sideLength);
    };
    /**
     * Draws a filled square of the specified size, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the square
     * @param  y the y-coordinate of the center of the square
     * @param  halfLength one half the length of any side of the square
     * @throws Error if halfLength is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.filledSquare = function (x, y, halfLength) {
        assert_1.default(halfLength <= 0, 'halfLength must be positive number');
        StdDraw._assertXYSafeInt(x, y);
        var x0 = x - halfLength;
        var y0 = y - halfLength;
        var sideLength = 2 * halfLength;
        var ctx = StdDraw.ctx;
        ctx.fillRect(x0, y0, sideLength, sideLength);
    };
    /**
     * Draws a rectangle of the specified size, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the rectangle
     * @param  y the y-coordinate of the center of the rectangle
     * @param  halfWidth one half the width of the rectangle
     * @param  halfHeight one half the height of the rectangle
     * @throws Error if either halfWidth or halfHeight is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.rectangle = function (x, y, halfWidth, halfHeight) {
        StdDraw._assertXYSafeInt(x, y);
        assert_1.default(halfWidth <= 0, 'halfWidth must be positive number');
        assert_1.default(halfHeight <= 0, 'halfHeight must be positive number');
        var x0 = x - halfWidth;
        var y0 = y - halfHeight;
        var width = 2 * halfWidth;
        var height = 2 * halfHeight;
        var ctx = StdDraw.ctx;
        ctx.strokeRect(x0, y0, width, height);
    };
    /**
     * Draws a filled rectangle of the specified size, centered at (x, y).
     *
     * @param  x the x-coordinate of the center of the rectangle
     * @param  y the y-coordinate of the center of the rectangle
     * @param  halfWidth one half the width of the rectangle
     * @param  halfHeight one half the height of the rectangle
     * @throws Error if either halfWidth or halfHeight is negative
     * @throws Error if any argument is either NaN or infinite
     */
    StdDraw.filledRectangle = function (x, y, halfWidth, halfHeight) {
        StdDraw._assertXYSafeInt(x, y);
        assert_1.default(halfWidth <= 0, 'halfWidth must be positive number');
        assert_1.default(halfHeight <= 0, 'halfHeight must be positive number');
        var x0 = x - halfWidth;
        var y0 = y - halfHeight;
        var width = 2 * halfWidth;
        var height = 2 * halfHeight;
        var ctx = StdDraw.ctx;
        ctx.fillRect(x0, y0, width, height);
    };
    /**
     * Draws a polygon with the vertices
     * (x0, y0),
     * (x1, y1), ...,
     * (xn - 1, yn - 1).
     *
     * @param  x an array of all the x-coordinates of the polygon
     * @param  y an array of all the y-coordinates of the polygon
     * @throws Error unless x[] and y[]
     *         are of the same length
     * @throws Error if any coordinate is either NaN or infinite
     * @throws Error if either x[] or y[] is null
     */
    StdDraw.polygon = function (x, y) {
        StdDraw._polygonPath(x, y);
        var ctx = StdDraw.ctx;
        ctx.stroke();
    };
    /**
     * Draws a filled polygon with the vertices
     * (x0, y0),
     * (x1, y1), ...,
     * (xn - 1, yn - 1).
     *
     * @param  x an array of all the x-coordinates of the polygon
     * @param  y an array of all the y-coordinates of the polygon
     * @throws Error unless x[] and y[]
     *         are of the same length
     * @throws Error if any coordinate is either NaN or infinite
     * @throws Error if either x[] or y[] is null
     */
    StdDraw.filledPolygon = function (x, y) {
        StdDraw._polygonPath(x, y);
        var ctx = StdDraw.ctx;
        ctx.fill();
    };
    StdDraw.setScale = function (x, y) {
        var ctx = StdDraw.ctx;
        StdDraw.scaleX = x;
        StdDraw.scaleY = -y;
        // Canvas has reverse y-coordinate
        ctx.scale(x, -y);
    };
    StdDraw.setTranslate = function (x, y) {
        StdDraw._assertXYSafeInt(x, y);
        var ctx = StdDraw.ctx;
        ctx.translate(x, y);
    };
    /**
     * Sets the pen size to the default size (0.002).
     * The pen is circular, so that lines have rounded ends, and when you set the
     * pen radius and draw a point, you get a circle of the specified radius.
     * The pen radius is not affected by coordinate scaling.
     */
    StdDraw.setPenRadius = function (r) {
        var ctx = StdDraw.ctx;
        ctx.lineWidth = 2 * r;
        ctx.lineCap = 'round';
    };
    /**
     * Sets the pen color to the specified color.
     *
     * The predefined pen colors are
     *   StdDraw.BLACK,   StdDraw.BLUE,   StdDraw.CYAN,
     *   StdDraw.DARK_GRAY,   StdDraw.GRAY,   StdDraw.GREEN,
     *   StdDraw.LIGHT_GRAY,   StdDraw.MAGENTA,   StdDraw.ORANGE,
     *   StdDraw.PINK,   StdDraw.RED,   StdDraw.WHITE, and
     *   StdDraw.YELLOW.
     *
     * @param color the color to make the pen
     */
    StdDraw.setPenColor = function (c) {
        var ctx = StdDraw.ctx;
        ctx.strokeStyle = c;
    };
    /**
     * Sets the font to the specified value.
     *
     * @param font the font
     */
    StdDraw.setFont = function (f) {
        var ctx = StdDraw.ctx;
        ctx.font = f;
    };
    /**
     * Sets the canvas (drawing area) to be 512-by-512 pixels.
     * This also erases the current drawing and resets the coordinate system,
     * pen radius, pen color, and font back to their default values.
     * Ordinarly, this method is called once, at the very beginning
     * of a program.
     */
    StdDraw.setCanvasSize = function (width, height) {
        StdDraw._assertXYSafeInt(width, height);
        assert_1.default(width > 0, 'width must greater than 0');
        assert_1.default(height > 0, 'width must greater than 0');
        var canvas = StdDraw.canvas;
        canvas.width = width;
        canvas.height = height;
    };
    /**
     * Clears the screen to the specified color.
     *
     * @param color the color to make the background
     */
    StdDraw.clear = function (color) {
        var ctx = StdDraw.ctx;
        ctx.clearRect(0, 0, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    };
    StdDraw.show = function (time) { };
    StdDraw._polygonPath = function (x, y) {
        var e_1, _a;
        assert_1.default(!!x, 'x-coordinate array');
        assert_1.default(!!y, 'y-coordinate array');
        assert_1.default(x.length !== y.length, 'arrays must be of the same length');
        var ctx = StdDraw.ctx;
        ctx.beginPath();
        var _b = tslib_1.__read(x.map(function (iX, index) { return [iX, y[index]]; })), _c = tslib_1.__read(_b[0], 2), firstX = _c[0], firstY = _c[1], points = _b.slice(1);
        ctx.moveTo(firstX, firstY);
        try {
            for (var points_1 = tslib_1.__values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                var _d = tslib_1.__read(points_1_1.value, 2), _x = _d[0], _y = _d[1];
                ctx.lineTo(_x, _y);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        ctx.closePath();
    };
    StdDraw._circlePath = function (x, y, radius) {
        assert_1.default(radius < 0, 'radius must not negative');
        StdDraw._assertXYSafeInt(x, y);
        var ctx = StdDraw.ctx;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, true);
    };
    StdDraw._ellipsePath = function (x, y, semiMajorAxis, semiMinorAxis) {
        StdDraw._assertXYSafeInt(x, y);
        var ctx = StdDraw.ctx;
        ctx.beginPath();
        ctx.ellipse(x, y, semiMajorAxis, semiMinorAxis, 0, 0, 2 * Math.PI, true);
    };
    StdDraw.getRad = function (degree) {
        return (degree / 180) * Math.PI;
    };
    StdDraw.drawAxis = function () {
        var ctx = StdDraw.ctx;
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        // Translate to cartesian coordinate system
        var offset = 20; // Offset for coordinate axis
        ctx.save();
        ctx.translate(0 + offset, StdDraw.DEFAULT_HEIGHT - offset);
        ctx.rotate(StdDraw.getRad(180));
        ctx.scale(-1, 1);
        StdDraw.drawAxisX();
        StdDraw.drawAxisY();
    };
    StdDraw.drawAxisX = function () {
        var ctx = StdDraw.ctx;
        ctx.save();
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'navy';
        ctx.fillStyle = 'navy';
        var width = StdDraw.DEFAULT_WIDTH - 40;
        // Draw axis
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(width, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(width - Math.cos(StdDraw.getRad(15)) * 10, Math.sin(StdDraw.getRad(15)) * 10);
        ctx.lineTo(width, 0);
        ctx.lineTo(width - Math.cos(StdDraw.getRad(15)) * 10, -Math.sin(StdDraw.getRad(15)) * 10);
        ctx.stroke();
        ctx.closePath();
        // Draw coordinates calibration
        var x;
        var y = 5;
        for (x = 50; x < width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.closePath();
        }
        // Draw coordinates numbers
        for (x = 0; x < width; x += 50) {
            ctx.save();
            ctx.scale(1, -1);
            ctx.fillText(x.toString(), x - 8, y + 10);
            ctx.restore();
        }
        ctx.restore();
    };
    StdDraw.drawAxisY = function () {
        var ctx = StdDraw.ctx;
        ctx.save();
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'navy';
        ctx.fillStyle = 'navy';
        var height = StdDraw.DEFAULT_HEIGHT - 62;
        // Draw axis
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, height);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(Math.sin(StdDraw.getRad(15)) * 10, height - Math.cos(StdDraw.getRad(15)) * 10);
        ctx.lineTo(0, height);
        ctx.lineTo(-Math.sin(StdDraw.getRad(15)) * 10, height - Math.cos(StdDraw.getRad(15)) * 10);
        ctx.stroke();
        ctx.closePath();
        // Draw coordinates calibration
        var y;
        var x = 5;
        for (y = 50; y < height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(0, y);
            ctx.stroke();
            ctx.closePath();
        }
        // Draw coordinates numbers
        x = -19;
        for (y = 50; y < height; y += 50) {
            ctx.save();
            ctx.scale(1, -1);
            ctx.translate(0, -height);
            ctx.fillText((height - y).toString(), x, y);
            ctx.restore();
        }
        ctx.restore();
    };
    /**
     * Create new canvas, container element must exist
     * @param containerId Canvas container id
     * @param canvasId new canvas id
     */
    StdDraw.createNewCanvas = function (containerId, canvasId) {
        if (document.getElementById(canvasId)) {
            throw new Error("Canvas(" + canvasId + ") already exist");
        }
        if (!document.getElementById(containerId)) {
            throw new Error("Canvas container(" + containerId + ") must exist");
        }
        StdDraw.canvas = StdDraw._createCanvas(containerId, canvasId);
        StdDraw.ctx = StdDraw._createContext();
        StdDraw.drawAxis();
    };
    StdDraw._createCanvas = function (containerId, canvasId) {
        if (containerId === void 0) { containerId = 'CanvasContainer'; }
        if (canvasId === void 0) { canvasId = 'StdCanvas'; }
        var _canvas = window.document.getElementById(canvasId);
        if (!_canvas) {
            _canvas = document.createElement('canvas');
            _canvas.id = canvasId;
            _canvas.width = StdDraw.DEFAULT_WIDTH;
            _canvas.height = StdDraw.DEFAULT_HEIGHT;
            // _canvas.width = 440;
            // _canvas.height = 240;
            _canvas.style.background = '#fff';
            _canvas.style.border = '1px solid #eee';
            var canvasContainer = document.getElementById(containerId);
            if (!canvasContainer) {
                throw new Error(containerId + " element not found");
            }
            canvasContainer.appendChild(_canvas);
        }
        return _canvas;
    };
    StdDraw._createContext = function () {
        var _ctx = StdDraw.canvas.getContext('2d');
        if (!_ctx) {
            throw new Error('Canvas element not found');
        }
        // _ctx.scale(StdDraw.scaleX, StdDraw.scaleY);
        _ctx.fillStyle = '#000';
        _ctx.strokeStyle = '#000';
        _ctx.save();
        return _ctx;
    };
    StdDraw._assertXYSafeInt = function (x, y) {
        assert_1.default(!Number.isSafeInteger(x) || !Number.isSafeInteger(y), 'x or y is either NaN or infinite');
    };
    StdDraw.scaleX = 1;
    StdDraw.scaleY = -1;
    StdDraw.DEFAULT_WIDTH = 512;
    StdDraw.DEFAULT_HEIGHT = 512;
    StdDraw.canvas = StdDraw._createCanvas();
    StdDraw.ctx = StdDraw._createContext();
    /** @see https://www.colorhexa.com/ */
    StdDraw.DARK_GRAY = '#a9a9a9';
    StdDraw.RED = '#ff0000';
    return StdDraw;
}());
exports.default = StdDraw;
StdDraw.drawAxis();
//# sourceMappingURL=index.js.map